# 软件设计之美

## 如何学习软件设计？

软件设计的相关知识很多，比如设计模式、领域驱动设计等。但通常学习后很难用起来。

**软件设计学习的难度，不在于一招一式，而是在于融会贯通。**

软件设计，我们可以从两个维度划分： **了解现有软件的设计** 和 **自己设计一个软件**。

了解现有软件的设计，是能够在这个软件上继续添砖加瓦的前提。只有了解现有软件的设计，才可能投入工作中；当你想从一个开源项目上汲取养分时，了解其背后的设计，也是一种不可或缺的能力。

了解一个现有软件设计的方法，最快速的是抓住这个软件最核心的三个部分： **模型、接口和实现**。

当在业务和技能上有了一定的积累，将有机会做属于自己的设计，随着负责的内容逐渐增多，复杂度也会升级，对软件设计能力的要求也会提高。

这时就需要掌握一些软件设计的基础知识。软件设计中最重要的部分包括：
+ 程序设计语言
+ 编程范式
+ 设计原则
+ 设计模式
+ 设计方法


**程序设计语言**，是软件设计落地的基础。任何设计都依赖程序设计语言来实现。但任何语言都有自己都局限，**要横跨语言学语言，不再局限于某一种语言，二十择其善者而从之，更好地落地你都设计。**


**编程范式**，是代码编写的风格，决定你在设计时，可以用到那些元素：是模块、是对象，还是函数。在不同层次的设计中，选择不同的编程范式已经成为今天开发的主流。目前最主流的编程范式，包括： 结构化编程、面向对象编程和函数式编程，建立其软件设计的根基。

**设计原则**，是你在进入具体设计的层面时，可以用来判断自己工作结果的一个衡量标准。面向对象的主流设计原则： SOLID原则。一方面面向对象是当今主流开发方式，另一方面SOLID原则也是比较成体系的设计原则，其本身也在不断发展。

**设计模式**，是设计原则在具体场景下的应用。不过这个话题展开后，内容很很多，很多书和课程也都讲到了。可以通过一些设计模式的心得，将设计模式的相关知识贯穿起来。

**设计方法**，是在有了诸多工具之后，用这个工具进行自己的设计。这可以用**领域驱动设计**（也就是DDD，Domain Driven Design）进行讲解，这是目前最为完整、有效的应对复杂业务场景的设计方法，包括了从如何识别概念到如何建立模型。通过对 DDD的基础知识贯穿起来，做一个结构性的掌握，这样就可以知道，有了前面知识的铺垫，DDD理解起来一点都不困难。

有了基础知识，还需要在**巩固篇**中实战一下，将学到的软件应用起来。结合开源项目 Moco, 看看如何设计一个程序库；借着一个数据采集的项目，看如何构建其一个可扩展的模型。大多数人在实际工作中面对的都是一个既有项目，看看对既有项目做设计上的改进。

## 软件设计之美 课程大纲

+ 开篇词  软件设计，应对需求规模的“算法”

* 课前必读
- 01 软件设计到底是什么？
- 02 分离关注点：软件设计至关重要的第一步
- 03 可测试性：一个影响软件设计的重要因素

* 了解一个软件的设计
- 04 三步走：如何了解一个软件的设计？
- 05 Spring DI容器：如何分析一个软件的模型？
- 06 Ruby on Rails: 如何分析一个软件的接口？
- 07 Kafka： 如何分析一个软件的实现？

* 设计一个软件
* 程序设计语言
- 08 语言的模型： 如何打破单一语言局限，让设计更好落地？
- 09 语言的接口： 语法和程序库，软件设计的发力点
- 10 语言的实现： 运行时，软件设计的地基
- 11 DSL：你也可以设计一门自己的语言

* 编程范式
- 12 编程范式：明明写的是 Java，为什么有人说是C代码？
- 13 结构化编程： 为什么做设计时仅有结构化编程是不够的？
- 14 面向对象之封装： 怎样封装才算是高内聚？
- 15 面向对象之继承： 继承是代码复用的合理方式吗？
- 16 面向对象之多态： 稀疏平常的多态，却是软件设计的大杀器？
- 17 函数式编程： 不用函数式编程语言，怎么写函数式的程序？
- 18 函数式编程之组合型： 函数式编程为什么如此吸引人？
- 19 函数式编程之不变性： 怎样保证我的代码不会被别人破坏？

* 设计原则与模式
- 20 单一职责原则： 你的模块到底为谁负责？
- 21 开放封闭原则： 不改代码怎么写新功能？
- 22 Liskov 替换原则：用了继承，子类就设计对了吗？
- 23 接口隔离原则： 接口里的方法，你都用得到吗？
- 24 依赖倒置原则： 高层代码和底层代码，到底谁该依赖谁？
- 25 设计模式： 每一种都是一个特定问题的解决方案
- 26 简单设计： 难道一开始就要把设计做复杂吗？

* 设计方法
- 27 领域驱动设计：如何从零开始设计一个软件？
- 28 战略设计：如何划分系统的模块？
- 29 战术设计： 如何构建一个可扩展的模型？

* 巩固篇
- 30 程序库的设计： Moco是如何解决集成问题的？
- 31 应用的设计： 如何设计一个数据采集平台？
- 32 应用的改进： 如何改进我们的软件设计？
- 结束语： 那些没有讲的事儿